{"noir_version":"0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c","hash":3848190217002194877,"abi":{"parameters":[{"name":"pubkey","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pubkey_redc_param","type":{"kind":"struct","path":"noir_rsa::bignum::BigNum","fields":[{"name":"limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"ZY3BCoMwEET/Zc+5aDdtya+UUlaNJRA2YmKhhPy7G0U8eJs382AyDLZbvh/HY4hgXhl86Cm5wEIZdNNuZZyIK8dEcwKDz7sCywMY3WBRMDpvJd+KuqgaWzxcxMcp6/IW+NHsqPO2vtVt4f44F0z/aV/EXQE=","file_map":{"53":{"source":"use dep::noir_rsa::bignum::BigNum;\nuse dep::noir_rsa::bignum::runtime_bignum::BigNumInstance;\nuse dep::noir_rsa::bignum::fields::Params2048;\nuse dep::noir_rsa::RSA;\n\ntype BN2048 = BigNum<18, Params2048>;\ntype BNInstance = BigNumInstance<18, Params2048>;\ntype RSA2048 = RSA<BN2048, BNInstance, 256>;\n\nfn main(pubkey: [u8; 256], signature: [u8; 256], pubkey_redc_param: BN2048) {\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    let modulus: BN2048 = BigNum::from_byte_be(pubkey);\n    let signature: BN2048 = BigNum::from_byte_be(signature);\n\n    // let instance: BNInstance = BigNumInstance::new(modulus, pubkey_redc_param);\n\n    // let rsa: RSA2048 = RSA {};\n    // assert(rsa.verify_sha256_pkcs1v15(BNInstance, sha256_hash, signature));\n}","path":"/home/jpag/Playground/zkeml/noir_zkemail/src/main.nr"},"55":{"source":"use dep::std;\nuse crate::utils::u60_representation::U60Repr;\nuse crate::utils::arrayX::ArrayX;\nuse crate::utils::split_bits;\nuse crate::BigNum;\n\n/**\n * @brief runtime_bignum::BigNumTrait defines methods available to BigNum *if* the modulus is not known at compile time.\n *        e.g. RSA where the modulus is a witness value as it changes for every RSA signature\n *        tee `lib.nr` for a trait definition where the modulus is known at compile time\n **/\ntrait BigNumTrait {\n    fn new() -> Self;\n    fn one() -> Self;\n    fn from(limbs: [Field]) -> Self;\n    fn from_byte_be<let NBytes: u64>(x: [u8; NBytes]) -> Self;\n    fn to_le_bytes<let NBytes: u64>(val: Self) -> [u8; NBytes];\n    fn get(self) -> [Field];\n    fn get_limb(self, idx: u64) -> Field;\n    fn set_limb(&mut self, idx: u64, value: Field);\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn validate_in_range(self);\n    fn validate_quotient_in_range(self);\n    fn __is_zero(self) -> bool;\n    fn __eq(self, rhs: Self) -> bool;\n}\n\n/**\n * @brief BigNumInstanceTrait defines methods available to a runtime BigNumInstance.\n *        BigNumInstance wraps the modulus parameter (as well as a Barret reduction parameter),\n *        which is required for the majority of BigNum operations\n **/\ntrait BigNumInstanceTrait<BN> where BN: BigNumTrait {\n    fn modulus(self) -> BN;\n    fn __derive_from_seed<let SeedBytes: u64>(self, seed: [u8; SeedBytes]) -> BN;\n    fn eq(self, lhs: BN, rhs: BN) -> bool;\n    fn __negate(self, val: BN) -> BN;\n    fn __addmod(self, lhs: BN, rhs: BN) -> BN;\n    fn __submod(self, lhs: BN, rhs: BN) -> BN;\n    fn __mulmod(self, lhs: BN, rhs: BN) -> BN;\n    fn __divmod(self, lhs: BN, rhs: BN) -> BN;\n    fn __batch_invert<let M: u64>(self, x: [BN; M]) -> [BN; M];\n    fn __batch_invert_slice(self, x: [BN]) -> [BN];\n\n    fn __invmod(self, val: BN) -> BN;\n    fn __powmod(self, val: BN, exponent: BN) -> BN;\n    fn __compute_quadratic_expression<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n        self,\n        lhs_terms: [[BN; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BN; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BN; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (BN, BN);\n\n    fn evaluate_quadratic_expression<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n        self,\n        lhs_terms: [[BN; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BN; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BN; ADD_N],\n        linear_flags: [bool; ADD_N]\n    );\n\n    fn validate_in_field(self, val: BN);\n    fn assert_is_not_equal(self, lhs: BN, rhs: BN);\n    fn neg(self, val: BN) -> BN;\n    fn add(self, lhs: BN, rhs: BN) -> BN;\n    fn sub(self, lhs: BN, rhs: BN) -> BN;\n    fn mul(self, lhs: BN, rhs: BN) -> BN;\n    fn div(self, lhs: BN, rhs: BN) -> BN;\n\n}\n\n/**\n * @brief BigNumParamsTrait defines a \"field\" with which to parametrise BigNum.\n * @description The \"field\" does not need to be prime, any value *should* work (TODO: test!)\n**/\ntrait BigNumParamsTrait<let N: u64> {\n    /**\n     * @brief modulus_bits = log2(modulus) rounded up\n     **/\n    fn modulus_bits() -> u64;\n}\n\nstruct BigNumInstance<let N: u64, Params> {\n    \n    /**\n     * @brief modulus: all BigNum operations are evaluated modulo this value\n     **/\n    modulus: [Field; N],\n\n    /**\n     * @brief modulus but represented in a U60Repr form\n     **/\n    modulus_u60: U60Repr<N, 2>,\n    modulus_u60_x4: U60Repr<N, 4>,\n\n    // /**\n    //  * @brief double_modulus: used when performing negations and subtractions\n    //  **/\n    double_modulus: [Field; N],\n    // /**\n    //  * @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    //  **/\n    redc_param: [Field; N],\n}\n\nimpl<let N: u64, Params> BigNum<N, Params> {\n    // some strange circular dependency problem means we need to define `new` as a member of BigNumTrait as well as a definition outside of the trait\n    // (delete this method to see. BigNumInstance methods that use BigNum::new() error out, and I can't find a way of declaring BigNum to satisfy BigNumTrait as part of the BigNumInstance definition because BigNumInstance has no contextual knowledge of the BigNum type...)\n    fn new() -> Self {\n        BigNum { limbs: [0; N] }\n    }\n    fn one() -> BigNum<N, Params> {\n        let mut result: Self = BigNum { limbs: [0; N] };\n        result.limbs[0] = 1;\n        result\n    }\n}\n\nimpl<let N: u64, Params> BigNumTrait for BigNum<N, Params> where Params: BigNumParamsTrait<N> {\n\n    fn new() -> Self {\n        BigNum::new()\n    }\n    fn one() -> Self {\n        BigNum::one()\n    }\n\n    fn from(limbs: [Field]) -> Self { BigNum{ limbs: limbs.as_array() }}\n\n    /**\n     * @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n     * @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n     *               is precisely large enough to cover Params::modulus_bits()\n     * @param x: input byte array\n     **/\n    fn from_byte_be<let NBytes: u64>(x: [u8; NBytes]) -> BigNum<N, Params> {\n        let num_bits: u64 = NBytes * 8;\n        let modulus_bits: u64 = Params::modulus_bits();\n        assert(num_bits > modulus_bits);\n        assert(num_bits - modulus_bits < 8);\n        let mut result = BigNum::new();\n\n        let excess_bytes = N * 15 - NBytes;\n        let final_limb_bytes = 15 - excess_bytes;\n        let mut limb: Field = 0;\n        let mut k = 0;\n        for _j in 0..final_limb_bytes {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result.limbs[N - 1] = limb;\n\n        for i in 1..N {\n            let mut limb: Field = 0;\n            for _j in 0..15 {\n                limb *= 256;\n                limb += x[k] as Field;\n                k += 1;\n            }\n            result.limbs[N - i - 1] = limb;\n        }\n\n        // max_bits_in_most_significant_byte should be known at comptime. if not...messy!\n        let mut max_bits_in_most_significant_byte = num_bits - modulus_bits;\n        if num_bits == modulus_bits {\n            max_bits_in_most_significant_byte = 8;\n        }\n\n        let most_significant_byte: Field = x[NBytes - 1] as Field;\n        most_significant_byte.assert_max_bit_size(max_bits_in_most_significant_byte as u32);\n        result\n    }\n\n    fn to_le_bytes<let NBytes: u64>(val: BigNum<N, Params>) -> [u8; NBytes] {\n        let nbytes = (Params::modulus_bits() / 8) + (Params::modulus_bits() % 8 != 0) as u64;\n        assert(nbytes <= NBytes);\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..N - 1 {\n            let limb_bytes = val.limbs[i].to_le_bytes(15);\n            for j in 0..15 {\n                result[i * 15 + j] = limb_bytes[j];\n            }\n        }\n        let last_limb_bytes = val.limbs[N - 1].to_le_bytes(15);\n        let num_last_bytes = (NBytes - (N - 1) * 15);\n        for i in 0..num_last_bytes {\n            result[(N-1) * 15 + i] = last_limb_bytes[i];\n        }\n        result\n    }\n\n    fn get(self) -> [Field] {\n        self.limbs\n    }\n    fn get_limb(self, idx: u64) -> Field {\n        self.limbs[idx]\n    }\n    fn set_limb(&mut self, idx: u64, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    /**\n     * @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n     * @description should be cheaper than using an IF statement (TODO: check!)\n     **/\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let mut result: Self = lhs;\n        for i in 0..N {\n            result.limbs[i] = (lhs.limbs[i] - rhs.limbs[i]) * predicate as Field + rhs.limbs[i];\n        }\n        result\n    }\n\n    /**\n     * @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n     **/\n    fn validate_in_range(self) {\n        for i in 0..(N - 1) {\n            self.limbs[i].assert_max_bit_size(120);\n        }\n        let final_limb_bits = Params::modulus_bits() - ((N - 1) * 120);\n        self.limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n    }\n\n    /**\n     * @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n     * @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n     *              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n     *              Why is this?\n     *              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n     *                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n     *                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n     *              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n     *\n     *              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n     *              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n     **/\n    fn validate_quotient_in_range(self) {\n        for i in 0..(N) {\n            self.limbs[i].assert_max_bit_size(120);\n        }\n        // Note: replace magic number 6 with definition\n        let final_limb_bits = Params::modulus_bits() - ((N - 1) * 120) + 6;\n        self.limbs[N - 1].assert_max_bit_size(final_limb_bits as u32);\n    }\n\n    fn __is_zero(self) -> bool {\n        self.__is_zero_impl()\n    }\n\n    fn __eq(self, rhs: Self) -> bool {\n        self.__eq_impl(rhs)\n    }\n}\n\nimpl<let N: u64, Params> BigNum<N, Params> where Params: BigNumParamsTrait<N> {\n\n    fn from_array(limbs: [Field; N]) -> BigNum<N, Params> {\n        BigNum { limbs }\n    }\n\n    unconstrained fn __is_zero_impl(self) -> bool {\n        let mut result: bool = true;\n        for i in 0..N {\n            result = result & (self.limbs[i] == 0);\n        }\n        result\n    }\n\n    unconstrained fn __eq_impl(lhs: Self, rhs: Self) -> bool {\n        lhs.limbs == rhs.limbs\n    }\n}\n\nimpl<let N: u64, Params,> BigNumInstanceTrait<BigNum<N, Params>> for BigNumInstance<N, Params> where Params: BigNumParamsTrait<N> {\n\n    fn modulus(self) -> BigNum<N, Params> { BigNum{ limbs: self.modulus } }\n    fn __derive_from_seed<let SeedBytes: u64>(self, seed: [u8; SeedBytes]) -> BigNum<N, Params> {\n        self.__derive_from_seed_impl(seed)\n    }\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### U N C O N S T R A I N E D    F U N C T I O N S\n    // ### NOTE: these functions call unconstrained internal implementations because trait impl modifiers are not supported \n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    fn __negate(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__negate_impl(val)\n    }\n\n    fn __addmod(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__addmod_impl(lhs, rhs)\n    }\n\n    fn __submod(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__submod_impl(lhs, rhs)\n    }\n\n    fn __mulmod(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__mulmod_impl(lhs, rhs)\n    }\n\n    fn __divmod(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__divmod_impl(lhs, rhs)\n    }\n\n    fn __batch_invert<let M: u64>(self, x: [BigNum<N, Params>; M]) -> [BigNum<N, Params>; M] {\n        self.batch_invert_impl(x)\n    }\n\n    // n.b. needs to be declared unconstrained because we return a slice from an unconstrained runtime\n    unconstrained fn __batch_invert_slice(self, x: [BigNum<N, Params>]) -> [BigNum<N, Params>] {\n        self.batch_invert_slice_impl(x)\n    }\n\n    fn __invmod(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__invmod_impl(val)\n    }\n\n    fn __powmod(self, val: BigNum<N, Params>, exponent: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__powmod_impl(val, exponent)\n    }\n\n    fn __compute_quadratic_expression<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n            self,\n            lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n            lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n            rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n            rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n            linear_terms: [BigNum<N, Params>; ADD_N],\n            linear_flags: [bool; ADD_N]\n        ) -> (BigNum<N, Params>, BigNum<N, Params>) {\n            self.__compute_quadratic_expression_impl(\n                lhs_terms,\n                lhs_flags,\n                rhs_terms,\n                rhs_flags,\n                linear_terms,\n                linear_flags\n            )\n    }\n\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### C O N S T R A I N E D    F U N C T I O N S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n\n    /**\n     * @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n     * @description The expression is of the form (when evaluated as an integer relation):\n     *\n     * \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n     *\n     * The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n     *\n     * Note: this method requires the remainder term of the expression to be ZERO\n     * When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n     * This can be achieved by minimizing the number of degree-2 relations required.\n     *\n     * The expensive parts of this algorithm are the following:\n     *      1. evaluating the limb products required to compute `lhs * rhs`\n     *      2. applying range constraints to validate the result is 0\n     *\n     * Range constraints are needed for the following reason:\n     * When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n     * Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n     * Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n     * To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n     * (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n     * To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n     * We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n     * TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n     * I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n     * TODO: explain why we apply a 126-bit range check, this feels like a magic number\n     * (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n     * TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n     * \n     * @param lhs_terms a 2D array of BigNum\n     * @param lhs_flags a 2D array of sign flags\n     * @param rhs_terms a 2D array of BigNum\n     * @param rhs_flags a 2D array of sign flags\n     * @param linear_terms an array of BigNum\n     * @param linear_flags an array of sign flags\n     **/\n    fn evaluate_quadratic_expression<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) {\n        // use an unconstrained function to compute the value of the quotient\n        let (quotient, _, borrow_flags): (BigNum<N, Params>, BigNum<N, Params>, ArrayX<Field, N, 2>) = self.__compute_quadratic_expression_with_borrow_flags(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        );\n        // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n        // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n        quotient.validate_quotient_in_range();\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        // (should be a compile-time check...unconstrained function?)\n\n        // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n        let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut t4: [Field; N] = [0; N];\n\n        // TODO: this is super nasty as it requires a multiplication\n        let double_modulus: [Field; N] = self.double_modulus;\n        for k in 0..NUM_PRODUCTS {\n            for i in 0..N {\n                for j in 0..LHS_N {\n                    // note: if is_negative is not known at comptime this is very expensive\n                    if (lhs_flags[k][j]) {\n                        t0[k][i] -= lhs_terms[k][j].limbs[i];\n                        t0[k][i] += double_modulus[i];\n                    } else {\n                        t0[k][i] += lhs_terms[k][j].limbs[i];\n                    }\n                }\n                for j in 0..RHS_N {\n                    if (rhs_flags[k][j]) {\n                        t1[k][i] -= rhs_terms[k][j].limbs[i];\n                        t1[k][i] += double_modulus[i];\n                    } else {\n                        t1[k][i] += rhs_terms[k][j].limbs[i];\n                    }\n                }\n            }\n        }\n        for i in 0..N {\n            for j in 0..ADD_N {\n                if (linear_flags[j]) {\n                    t4[i] -= linear_terms[j].limbs[i];\n                    t4[i] += double_modulus[i];\n                } else {\n                    t4[i] += linear_terms[j].limbs[i];\n                }\n            }\n        }\n\n        // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n        // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n        // so that we can ensure that no limbs will underflow for an honest Prover\n        let mut product_limbs: ArrayX<Field, N,2> = ArrayX::new();\n        //       let fff: [Field; N] = quotient.limbs;\n        //      let mut borrow_flags: ArrayX<Field, N,2> = BigNum::get_borrow_flags3(t0, t1, t2, t3, t4, fff, self.modulus);\n\n        // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n        // TODO: this is super nasty as it requires a multiplication\n        for i in 0..N {\n            for j in 0..N {\n                for k in 0..NUM_PRODUCTS {\n                    if k == 0 {\n                        let new_term = t0[k][i] * t1[k][j] - quotient.limbs[i] * self.modulus[j];\n                        std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                        product_limbs.add_assign(i + j, new_term);\n                    } else {\n                        product_limbs.add_assign(i + j, t0[k][i] * t1[k][j]);\n                    }\n                }\n                if (NUM_PRODUCTS == 0) {\n                    product_limbs.sub_assign(i + j, quotient.limbs[i] * self.modulus[j]);\n                }\n            }\n            product_limbs.add_assign(i, t4[i]);\n        }\n\n        // each limb product represents the sum of 120-bit products.\n        // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n        // where no more than 64 limb products are summed together.\n        // TODO: check in unconstrained function that this condition is satisfied\n        // TODO: define trade-offs regarding the value of borrow_shift\n        // (the larger the value, the greater the range check that is required on product_limbs)\n        // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n        // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n        let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n        let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n\n        // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n        //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n        // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n        borrow_flags.get(0).assert_max_bit_size(1);\n        product_limbs.add_assign(0, borrow_flags.get(0) * borrow_shift);\n        for i in 1..(N + N - 2) {\n            borrow_flags.get(i).assert_max_bit_size(1);\n            product_limbs.add_assign(\n                i,\n                (borrow_flags.get(i) * borrow_shift - borrow_flags.get(i - 1) * borrow_carry)\n            );\n        }\n        product_limbs.sub_assign(N + N - 2, borrow_flags.get(N + N - 3) * borrow_carry);\n\n        // Final step: Validate `product_limbs` represents the integer value `0`\n        // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n        // i.e. we need to do the following for each limb `i`:\n        //      1. validate the limb's low-120 bits equals zero\n        //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n        //      3. add the carry into limb `i+1`\n        // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n        // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n        // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n        //  where k is the number of bits in the prime field)\n        // We then add the result into the next limb and repeat.\n        let hi_shift: Field = 0x1000000000000000000000000000000;\n        let hi_downshift: Field = 1 / hi_shift;\n        for i in 0..N + N - 2 {\n            product_limbs.mul_assign(i, hi_downshift);\n            std::as_witness(product_limbs.get(i));\n            product_limbs.get(i).assert_max_bit_size(126); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n            product_limbs.add_assign(i + 1, product_limbs.get(i));\n        }\n        // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n        assert(product_limbs.get(N + N - 2) == 0);\n    }\n\n    fn validate_in_field(self, val: BigNum<N, Params>) {\n        // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n        let mut p_minus_self: [Field; N] = [0; N];\n        let modulus: [Field; N] = self.modulus;\n        for i in 0..N {\n            p_minus_self[i] = modulus[i] - val.limbs[i];\n        }\n        let borrow_flags = self.__validate_in_field_compute_borrow_flags(val);\n        let two_pow_120: Field = 0x1000000000000000000000000000000;\n        p_minus_self[0] += borrow_flags[0] as Field * two_pow_120;\n        for i in 1..N - 1 {\n            p_minus_self[i] += (borrow_flags[i] as Field * two_pow_120 - borrow_flags[i-1] as Field);\n        }\n        p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n        let mut compare = val;\n        compare.limbs = p_minus_self;\n        compare.validate_in_range();\n    }\n\n    /**\n     * @brief Validate self != other\n     * @details If A == B, then A == B mod N.\n     *          We can efficiently evaluate A == B mod N where N = circuit modulus\n     *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n     *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n     *          (todo: compute how tiny)\n     **/\n    fn assert_is_not_equal(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) {\n        let mut l: Field = 0;\n        let mut r: Field = 0;\n        let mut modulus_mod_n: Field = 0;\n        let mut two_pow_120: Field = 0x1000000000000000000000000000000;\n        let modulus = self.modulus;\n        for i in 0..N {\n            l *= two_pow_120;\n            r *= two_pow_120;\n            modulus_mod_n *= two_pow_120;\n            l += lhs.limbs[N - i - 1];\n            r += rhs.limbs[N - i - 1] ;\n            modulus_mod_n += modulus[N - i - 1];\n        }\n\n        // lhs can be either X mod N or P + X mod N\n        // rhs can be either Y mod N or P + Y mod N\n        // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n        let mut diff = l - r;\n        let mut target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n        assert(target != 0, \"asssert_is_not_equal fail\");\n    }\n\n    fn eq(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> bool {\n        let diff = self.sub(lhs, rhs);\n        // if self == other, possible values of `diff` will be `p` or `0`\n        // (the subtract operator constrains diff to be < ceil(log(p)))\n        // TODO: can do this more efficiently via witngen in unconstrained functions?\n        let mut is_equal_modulus: bool = true;\n        let mut is_equal_zero: bool = true;\n        for i in 0..N {\n            is_equal_modulus = is_equal_modulus & (diff.limbs[i] == self.modulus[i]);\n            is_equal_zero = is_equal_zero & (diff.limbs[i] == 0);\n        }\n        is_equal_modulus | is_equal_zero\n    }\n\n    fn neg(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = self.__negate_with_flags(val);\n        result.validate_in_range();\n        let modulus = self.modulus;\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let result_limb = modulus[0] - val.limbs[0] - result.limbs[0] + (borrow_flags[0] as Field * borrow_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val.limbs[i] - result.limbs[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val.limbs[N - 1] - result.limbs[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n\n    fn add(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) = self.__add_with_flags(lhs, rhs);\n        result.validate_in_range();\n        let modulus = self.modulus;\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let carry_shift = 0x1000000000000000000000000000000;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let result_limb = lhs.limbs[0] + rhs.limbs[0] - subtrahend[0] - result.limbs[0]\n            + (borrow_flags[0] as Field * borrow_shift)\n            - (carry_flags[0] as Field * carry_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = lhs.limbs[i] + rhs.limbs[i]\n                - subtrahend[i]\n                - result.limbs[i]\n                - borrow_flags[i - 1] as Field\n                + carry_flags[i - 1] as Field\n                + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = lhs.limbs[N - 1] + rhs.limbs[N - 1]\n            - subtrahend[N - 1]\n            - result.limbs[N - 1]\n            - borrow_flags[N - 2] as Field\n            + carry_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, underflow) = self.__sub_with_flags(lhs, rhs);\n        result.validate_in_range();\n        let modulus = self.modulus;\n        let borrow_shift = 0x1000000000000000000000000000000;\n        let carry_shift = 0x1000000000000000000000000000000;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n        let result_limb = lhs.limbs[0] - rhs.limbs[0] + addend[0] - result.limbs[0]\n            + (borrow_flags[0] as Field * borrow_shift)\n            - (carry_flags[0] as Field * carry_shift);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = lhs.limbs[i] - rhs.limbs[i] + addend[i] - result.limbs[i] - borrow_flags[i - 1] as Field\n                + carry_flags[i - 1] as Field\n                + ((borrow_flags[i] as Field - carry_flags[i] as Field) * borrow_shift);\n            assert(result_limb == 0);\n        }\n        let result_limb = lhs.limbs[N - 1] - rhs.limbs[N - 1] + addend[N - 1]\n            - result.limbs[N - 1]\n            - borrow_flags[N - 2] as Field\n            + carry_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let result = self.__mulmod(lhs, rhs);\n        self.evaluate_quadratic_expression([[lhs]], [[false]], [[rhs]], [[false]], [result], [true]);\n        result\n    }\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let result = self.__divmod(lhs, rhs);\n        self.evaluate_quadratic_expression([[result]], [[false]], [[rhs]], [[false]], [lhs], [true]);\n        result\n    }\n\n}\n\nimpl<let N: u64, Params> BigNumInstance<N, Params> where Params: BigNumParamsTrait<N> {\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### C  O  N  S  T  R  U  C  T  O  R  S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    fn new(modulus: [Field; N], redc_param: [Field; N]) -> Self {\n        Self {\n            redc_param,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus)\n        }\n    }\n\n    unconstrained fn __derive_from_seed_impl<let SeedBytes: u64>(self, seed: [u8; SeedBytes]) -> BigNum<N, Params> {\n        let mut rolling_seed = seed;\n\n        let mut to_reduce: ArrayX<Field, N, 2> = ArrayX { segments: [[0; N], [0; N]] };\n\n        let mut double_modulus_bits = Params::modulus_bits() * 2;\n        let mut double_modulus_bytes = (double_modulus_bits) / 8 + (double_modulus_bits % 8 != 0) as u64;\n\n        let mut last_limb_bytes = double_modulus_bytes % 15;\n        if (last_limb_bytes == 0) {\n            last_limb_bytes = 15;\n        }\n        let mut last_limb_bits = double_modulus_bits % 8;\n        if (last_limb_bits == 0) {\n            last_limb_bits = 8;\n        }\n\n        for i in 0..(N - 1) {\n            let hash: [u8; 32] = std::hash::sha256(rolling_seed);\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n            for j in 0..15 {\n                hi *= 256;\n                lo *= 256;\n\n                if (i < 2 * N - 2) {\n                    lo += hash[j + 15] as Field;\n                    hi += hash[j] as Field;\n                }\n            }\n            to_reduce.set(2 * i, lo);\n            to_reduce.set(2 * i + 1, hi);\n            rolling_seed[0] += 1;\n        }\n\n        {\n            let hash: [u8; 32] = std::hash::sha256(rolling_seed);\n            let mut hi: Field = 0;\n            for j in 0..(last_limb_bytes - 1) {\n                hi *= 256;\n                hi += hash[j] as Field;\n            }\n            hi *= 256;\n            let last_byte = hash[last_limb_bytes - 1];\n            let mask = (1 as u64 << (last_limb_bits) as u8) - 1;\n            let last_bits = last_byte as u64 & mask;\n            hi += last_bits as Field;\n            to_reduce.set(2 * N - 2, hi);\n        }\n\n        let (_, remainder) = __barrett_reduction(\n            to_reduce,\n            self.redc_param,\n            Params::modulus_bits(),\n            self.modulus,\n            self.modulus_u60_x4\n        );\n        let mut result = BigNum::new();\n        result.limbs = remainder;\n        result\n    }\n\n    // ####################################################################################################################\n    // ####################################################################################################################\n    // ### U N C O N S T R A I N E D    F U N C T I O N S\n    // ####################################################################################################################\n    // ####################################################################################################################\n\n    unconstrained fn __validate_in_field_compute_borrow_flags(self: Self, val: BigNum<N, Params>) -> [bool; N] {\n        let mut flags: [bool; N] = [false; N];\n        let modulus: [Field; N] = self.modulus;\n        flags[0] = modulus[0].lt(val.limbs[0]);\n        for i in 1..N - 1 {\n            flags[i] = modulus[i].lt(val.limbs[i] + flags[i - 1] as Field);\n        }\n        flags\n    }\n\n    unconstrained fn __powmod_impl(self, val: BigNum<N, Params>, exponent: BigNum<N, Params>) -> BigNum<N, Params> {\n        let x: U60Repr<N, 2> = U60Repr::from(exponent.limbs);\n\n        let num_bits = Params::modulus_bits() + 1;\n\n        let mut accumulator: BigNum<N, Params> = BigNum::one();\n\n        for i in 0..num_bits {\n            accumulator = self.__mulmod(accumulator, accumulator);\n            if x.get_bit(num_bits - i - 1) {\n                accumulator = self.__mulmod(accumulator, val);\n            }\n        }\n        accumulator\n    }\n\n    unconstrained fn __mulmod_with_quotient(\n        self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, BigNum<N, Params>) {\n        let mut mul: ArrayX<Field, N, 2> = ArrayX::new();\n        for i in 0..N {\n            for j in 0..N {\n                mul.add_assign(i + j, lhs.limbs[i] * rhs.limbs[j]);\n            }\n        }\n        let (q, r) = __barrett_reduction(\n            mul.__normalize_limbs(N + N),\n            self.redc_param,\n            Params::modulus_bits(),\n            self.modulus,\n            self.modulus_u60_x4\n        );\n\n        let mut quotient = BigNum::from_array(q);\n        let mut remainder = BigNum::from_array(r);\n        (quotient, remainder)\n    }\n\n    unconstrained fn __mulmod_impl(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let (_, b) = self.__mulmod_with_quotient(lhs, rhs);\n        b\n    }\n\n    unconstrained fn __addmod_impl(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        let x_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let y_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n\n        let mut z_u60 = x_u60 + y_u60;\n\n        if z_u60.gte(self.modulus_u60) {\n            z_u60 = z_u60 - self.modulus_u60;\n        }\n        let mut result = BigNum::from_array(U60Repr::into(z_u60));\n        result\n    }\n\n    /**\n     * @brief given an input `x`, compute `2p - x` (unconstrained)\n     *\n     * @description we subtract the input from double the modulus, because all constrained BigNum operations\n     *              only guarantee that the output is in the range [0, ceil(log2(p))].\n     *              I.E. the input may be larger than the modulus `p`.\n     *              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n     *              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n     *              because such a check is expensive and usually unneccesary.\n     */\n    unconstrained fn __negate_impl(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        let f: [Field; N] = val.limbs;\n        let x_u60 : U60Repr<N, 2> = U60Repr::from(f);\n        let mut result = BigNum::from_array(U60Repr::into(self.modulus_u60 - x_u60));\n        result\n    }\n\n    unconstrained fn __add_with_flags(\n        self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, [bool; N], [bool; N], bool) {\n        let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n        let add_u60 = a_u60 + b_u60;\n\n        let overflow = add_u60.gte(self.modulus_u60);\n\n        let mut subtrahend_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        if overflow {\n            subtrahend_u60 = self.modulus_u60;\n        }\n\n        let mut carry: u64 = 0;\n        let mut carry_in: u64 = 0;\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n        let mut borrow_flags: [bool; N] = [false; N];\n        let mut carry_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                let mut add_term: u64 = a_u60.limbs.segments[j][i] + b_u60.limbs.segments[j][i] + carry_in;\n                carry = (add_term >= 0x1000000000000000) as u64;\n                add_term -= (carry as u64 * 0x1000000000000000);\n                result_u60.limbs.segments[j][i] = add_term;\n                carry_in = carry as u64;\n                borrow = ((subtrahend_u60.limbs.segments[j][i] + borrow_in) > result_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + result_u60.limbs.segments[j][i]\n                    - subtrahend_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    if (carry & borrow == 1) {\n                        carry = 0;\n                        borrow = 0;\n                    }\n                    carry_flags[idx] = carry as bool;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n\n        (result, carry_flags, borrow_flags, overflow)\n    }\n\n    unconstrained fn __sub_with_flags(\n        self,\n        lhs: BigNum<N, Params>,\n        rhs: BigNum<N, Params>\n    ) -> (BigNum<N, Params>, [bool; N], [bool; N], bool) {\n        let a_u60 : U60Repr<N, 2> = U60Repr::from(lhs.limbs);\n        let b_u60 : U60Repr<N, 2> = U60Repr::from(rhs.limbs);\n\n        let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n        let mut addend_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        if underflow {\n            addend_u60 = self.modulus_u60;\n        }\n\n        let mut carry: u64 = 0;\n        let mut carry_in: u64 = 0;\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n        let mut borrow_flags: [bool; N] = [false; N];\n        let mut carry_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                let mut add_term: u64 = a_u60.limbs.segments[j][i] + addend_u60.limbs.segments[j][i] + carry_in;\n                carry = (add_term >= 0x1000000000000000) as u64;\n                add_term -= (carry as u64 * 0x1000000000000000);\n                result_u60.limbs.segments[j][i] = add_term;\n                carry_in = carry as u64;\n                borrow = ((b_u60.limbs.segments[j][i] + borrow_in) > result_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + result_u60.limbs.segments[j][i]\n                    - b_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    if (carry & borrow == 1) {\n                        carry = 0;\n                        borrow = 0;\n                    }\n                    carry_flags[idx] = carry as bool;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n        (result, carry_flags, borrow_flags, underflow)\n    }\n\n    unconstrained fn __negate_with_flags(self, val: BigNum<N, Params>) -> (BigNum<N, Params>, [bool; N]) {\n        let f: [Field; N] = val.limbs;\n        let x_u60 : U60Repr<N, 2> = U60Repr::from(f);\n        let mut result_u60 : U60Repr<N, 2> = U60Repr { limbs: ArrayX::new() };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        let mut borrow_flags: [bool; N] = [false; N];\n        for j in 0..2 {\n            for i in 0..N {\n                borrow = ((x_u60.limbs.segments[j][i] + borrow_in) > self.modulus_u60.limbs.segments[j][i]) as u64;\n                let sub = (borrow << 60) + self.modulus_u60.limbs.segments[j][i]\n                    - x_u60.limbs.segments[j][i]\n                    - borrow_in;\n                result_u60.limbs.segments[j][i] = sub;\n                borrow_in = borrow;\n                if ((j * N + i) & 1 == 1) {\n                    let idx = (j * N + i - 1) / 2;\n                    borrow_flags[idx] = borrow as bool;\n                }\n            }\n        }\n        let mut result = BigNum::from_array(U60Repr::into(result_u60));\n        (result, borrow_flags)\n    }\n\n    /**\n     * @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n     * @description see `__negate` for why we use 2p instead of p\n     **/\n    unconstrained fn __submod_impl(self, lhs: BigNum<N, Params>, rhs: BigNum<N, Params>) -> BigNum<N, Params> {\n        self.__addmod(lhs, self.__negate(rhs))\n    }\n\n    unconstrained fn __invmod_impl(self, val: BigNum<N, Params>) -> BigNum<N, Params> {\n        let one: BigNum<N, Params> = BigNum::one();\n        let one_u60: U60Repr<N, 2> = U60Repr::from(one.limbs);\n        let exponent = self.modulus_u60.sub(one_u60.add(one_u60));\n        let mut result = BigNum::from_array(U60Repr::into(exponent));\n        self.__powmod(val, result)\n    }\n\n    unconstrained fn batch_invert_impl<let M: u64>(self, x: [BigNum<N, Params>; M]) -> [BigNum<N, Params>; M] {\n        // TODO: ugly! Will fail if input slice is empty\n        let mut accumulator: BigNum<N, Params> = BigNum::one();\n        let mut result: [BigNum<N, Params>; M] = [BigNum::new(); M];\n        let mut temporaries: [BigNum<N, Params>] = &[];\n        for i in 0..x.len() {\n            temporaries = temporaries.push_back(accumulator);\n            if (x[i].__is_zero() == false) {\n                accumulator = self.__mulmod(accumulator, x[i]);\n            }\n        }\n\n        accumulator = self.__invmod(accumulator);\n        let mut T0: BigNum<N, Params> = BigNum::new();\n        T0.limbs = [0; N];\n        for i in 0..x.len() {\n            let idx = x.len() - 1 - i;\n            if (x[idx].__is_zero() == false) {\n                T0 = self.__mulmod(accumulator, temporaries[idx]);\n                accumulator = self.__mulmod(accumulator, x[idx]);\n                result[idx] = T0;\n            }\n        }\n        result\n    }\n\n    unconstrained fn batch_invert_slice_impl(self, x: [BigNum<N, Params>]) -> [BigNum<N, Params>] {\n        // TODO: ugly! Will fail if input slice is empty\n        let mut accumulator: BigNum<N, Params> = BigNum::one();\n        let mut result: [BigNum<N, Params>] = [BigNum::new()];\n        let mut temporaries: [BigNum<N, Params>] = &[];\n        for i in 0..x.len() {\n            temporaries = temporaries.push_back(accumulator);\n            if (x[i].__is_zero() == false) {\n                accumulator = self.__mulmod(accumulator, x[i]);\n            }\n            result = result.push_back(BigNum::new());\n        }\n\n        accumulator = self.__invmod(accumulator);\n        let mut T0: BigNum<N, Params> = BigNum::new();\n        T0.limbs = [0; N];\n        for i in 0..x.len() {\n            let idx = x.len() - 1 - i;\n            if (x[idx].__is_zero() == false) {\n                T0 = self.__mulmod(accumulator, temporaries[idx]);\n                accumulator = self.__mulmod(accumulator, x[idx]);\n                result[idx] = T0;\n            }\n        }\n        result\n    }\n\n    unconstrained fn __divmod_impl(self, numerator: BigNum<N, Params>, divisor: BigNum<N, Params>) -> BigNum<N, Params> {\n        let t0 = self.__invmod(divisor);\n        self.__mulmod(numerator, t0)\n    }\n\n    /**\n     * @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n     **/\n    // NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n    // To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n    // We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n    // Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n    // Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\n    unconstrained fn __add_linear_expression<let M: u64>(\n        self,\n        x: [BigNum<N, Params>; M],\n        flags: [bool; M]\n    ) -> ([Field; N]) {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        let mut sum: [Field; N] = [0; N];\n        // TODO: ugly! Will fail if input array is empty\n        let modulus2: [Field;N] = self.double_modulus;\n        for i in 0..M {\n            if (flags[i]) {\n                for j in 0..N {\n                    sum[j] = sum[j] + modulus2[j] - x[i].limbs[j];\n                    assert(x[i].limbs[j].lt(modulus2[j]));\n                }\n            } else {\n                for j in 0..N {\n                    sum[j] = sum[j] + x[i].limbs[j];\n                }\n            }\n        }\n        // problem if we normalize when used in computing quotient\n        sum\n        //   let result_p: ArrayX<Field, N, 1> = BigNum::__normalize_limbs(ArrayX::from_array(lhs_sum_p), N);\n        //  let result_n: ArrayX<Field, N, 1> = BigNum::__normalize_limbs(ArrayX::from_array(lhs_sum_n), N);\n        //  (result_p.segments[0], result_n.segments[0])\n    }\n\n    /**\n     * @brief computes the limb products of a quadratic expression\n     * @details see __compute_quadratic_expression_with_borrow_flags for full description\n     **/\n    unconstrained fn __compute_quadratic_expression_product<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> ArrayX<Field, N, 2> {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n        let mut add: [Field; N] = [0; N];\n\n        for i in 0..NUM_PRODUCTS {\n            lhs[i] = self.__add_linear_expression(lhs_terms[i], lhs_flags[i]);\n            rhs[i]= self.__add_linear_expression(rhs_terms[i], rhs_flags[i]);\n        }\n\n        let add: [Field; N] = self.__add_linear_expression(linear_terms, linear_flags);\n\n        let mut mulout: ArrayX<Field, N,2> = ArrayX::new();\n\n        for i in 0..N {\n            for j in 0..N {\n                for k in 0..NUM_PRODUCTS {\n                    mulout.add_assign(i + j, (lhs[k][i] * rhs[k][j]));\n                }\n            }\n            mulout.add_assign(i, add[i]);\n        }\n        mulout\n    }\n\n    /**\n     * @brief computes the quotient/remainder of a quadratic expression\n     * @details see __compute_quadratic_expression_with_borrow_flags for full description\n     **/\n    unconstrained fn __compute_quadratic_expression_impl<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (BigNum<N, Params>, BigNum<N, Params>) {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n        let mulout = self.__compute_quadratic_expression_product(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        );\n        let relation_result: ArrayX<Field, N, 2> = mulout.__normalize_limbs(N + N);\n\n        // TODO: ugly! Will fail if input slice is empty\n        let k  = Params::modulus_bits();\n\n        let (quotient, remainder) = __barrett_reduction(\n            relation_result,\n            self.redc_param,\n            k,\n            self.modulus,\n            self.modulus_u60_x4\n        );\n\n        let mut q = BigNum::from_array(quotient);\n        let mut r = BigNum::from_array(remainder);\n        (q, r)\n    }\n\n    /**\n     * @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n     * @description The expression is of the form:\n     *\n     * \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n     *\n     * The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n     *\n     * When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n     * This can be achieved by minimizing the number of degree-2 relations required.\n     *\n     * The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n     * For example, when computing the product a * b - q * p = 0, it is possible that:\n     *      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n     *      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n     * In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n     * In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n     *\n     * @param lhs_terms a 2D array of BigNum\n     * @param lhs_flags a 2D array of sign flags\n     * @param rhs_terms a 2D array of BigNum\n     * @param rhs_flags a 2D array of sign flags\n     * @param linear_terms an array of BigNum\n     * @param linear_flags an array of sign flags\n     **/\n    unconstrained fn __compute_quadratic_expression_with_borrow_flags<let LHS_N: u64, let RHS_N: u64, let NUM_PRODUCTS: u64, let ADD_N: u64>(\n        self,\n        lhs_terms: [[BigNum<N, Params>; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[BigNum<N, Params>; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [BigNum<N, Params>; ADD_N],\n        linear_flags: [bool; ADD_N]\n    ) -> (BigNum<N, Params>, BigNum<N, Params>, ArrayX<Field, N, 2>) {\n        // TODO, validate we do not overflow N2 when multiplying and N when adding\n\n        let mut mulout_p = self.__compute_quadratic_expression_product(\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags\n        );\n        let mut mulout_n: ArrayX<Field, N,2> = ArrayX::new();\n\n        let relation_result: ArrayX<Field, N, 2> = mulout_p.__normalize_limbs(N + N);\n        let modulus: [Field; N] = self.modulus;\n        let (quotient, remainder) = __barrett_reduction(\n            relation_result,\n            self.redc_param,\n            Params::modulus_bits(),\n            modulus,\n            self.modulus_u60_x4\n        );\n        assert(remainder == [0; N]);\n\n        for i in 0..N {\n            for j in 0..N {\n                mulout_n.add_assign(i + j, quotient[i] * modulus[j]);\n            }\n        }\n\n        // compute borrow flags from mulout_p and mulout_n\n        let mut borrow_flags: ArrayX<Field, N, 2> = ArrayX::new();\n        let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n        let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n        let two_pow_120: Field = 0x1000000000000000000000000000000;\n        let downshift: Field = 1 / two_pow_120;\n\n        // determine whether we need to borrow from more significant limbs.\n        // initial limb is \"simple\" comparison operation\n        // TODO: check how expensive `lt` operator is w.r.t. witness generation\n        borrow_flags.set(0, mulout_p.get(0).lt(mulout_n.get(0)) as Field);\n        // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n        // and there is nothing to borrow against for the final limb.\n        let mut hi_bits = (mulout_p.get(0) - mulout_n.get(0) + (borrow_flags.get(0) * borrow_shift)) * downshift;\n        for i in 1..(N + N - 2) {\n            // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n            // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n            //     * downshift;\n            mulout_p.add_assign(i, hi_bits);\n\n            // determine whether negative limb values are greater than positive limb values\n            let underflow: Field = mulout_p.get(i).lt(mulout_n.get(i) + (borrow_flags.get(i - 1) * borrow_carry)) as Field;\n            borrow_flags.set(i, underflow);\n\n            hi_bits = (mulout_p.get(i) - mulout_n.get(i) + (borrow_flags.get(i) * borrow_shift)\n                - (borrow_flags.get(i - 1) * borrow_carry)) * downshift;\n        }\n\n        let mut q = BigNum::from_array(quotient);\n        let mut r = BigNum::from_array(remainder);\n        (q, r, borrow_flags)\n    }\n}\n\nfn get_double_modulus<let N: u64>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n\nunconstrained fn __barrett_reduction<let N: u64>(\n    x: ArrayX<Field, N, 2>,\n    redc_param: [Field; N],\n    k: u64,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>\n) -> ([Field; N], [Field; N]) {\n    let mut mulout: ArrayX<Field, N, 3>  = ArrayX { segments: [[0; N]; 3] };\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout.add_assign(i + j, x.get(i) * redc_param[j]);\n        }\n    }\n    mulout = mulout.__normalize_limbs(3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n    let mut quotient_u60 = mulout_u60.shr((k + k));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient: ArrayX<Field, N, 2> = quotient_u60.into_arrayX();\n\n    // quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus: ArrayX<Field, N, 2>  = ArrayX { segments: [[0; N]; 2] };\n    let mut quotient_mul_modulus_normalized: ArrayX<Field, N, 2>  = ArrayX { segments: [[0; N]; 2] };\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus.add_assign(i + j, partial_quotient.get(i) * modulus[j]);\n        }\n    }\n\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus.get(i));\n        quotient_mul_modulus_normalized.set(i, lo);\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus.add_assign(i + 1, hi);\n        }\n    }\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n\n    let x_u60 : U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    } else {}\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n","path":"/home/jpag/nargo/github.com/noir-lang/noir-bignumv0.2.1/src/runtime_bignum.nr"}},"names":["main"]}